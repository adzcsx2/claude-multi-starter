#!/usr/bin/env python3
"""
ask - Send messages to Claude instances.

Usage:
    ask <instance> [options] <message>

Claude Instances:
    default, ui, coder, test, ... (configured in ccb.config)

Modes:
    Default (async):  Background task with hook callback
    --notify:         Sync send, no wait for reply (for notifications)

Examples:
    ask ui "Design a login page"
    ask coder "Implement the feature"
    ask claude --notify --no-wrap "Task completed"
"""

from __future__ import annotations

import os
import subprocess
import sys
import tempfile
from datetime import datetime
from pathlib import Path

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))

from compat import read_stdin_text, setup_windows_encoding
setup_windows_encoding()

from cli_output import EXIT_ERROR, EXIT_OK


# Known Claude instances (will be populated from providers.py if available)
_CLAUDE_INSTANCES = ["default"]


def _resolve_claude_target(target: str) -> tuple[str, str | None]:
    """
    Resolve Claude target to (provider, instance_id)

    Returns:
        (provider, instance_id)

    Examples:
        "claude" -> ("claude", None)
        "alpha" -> ("claude", "alpha")
        "claude:alpha" -> ("claude", "alpha")
        "beta" -> ("claude", "beta")
    """
    if ":" in target:
        provider, instance = target.split(":", 1)
        if provider.lower() == "claude":
            return ("claude", instance)
        return (provider.lower(), None)

    if target in _CLAUDE_INSTANCES:
        return ("claude", target)

    if target == "claude":
        return ("claude", None)

    return (target, None)


def make_task_id() -> str:
    """Generate task ID: YYYYMMDD-HHMMSS-mmm-PID"""
    now = datetime.now()
    ms = now.microsecond // 1000
    return f"{now.strftime('%Y%m%d-%H%M%S')}-{ms:03d}-{os.getpid()}"


def _usage() -> None:
    print("Usage: ask <instance> [options] <message>", file=sys.stderr)
    print("", file=sys.stderr)
    print("Claude Instances:", file=sys.stderr)
    print("  default, ui, coder, test, ... (configured in ccb.config)", file=sys.stderr)
    print("  Use directly: ask ui \"message\"", file=sys.stderr)
    print("  Or with prefix: ask claude:ui \"message\"", file=sys.stderr)
    print("", file=sys.stderr)
    print("Options:", file=sys.stderr)
    print("  -h, --help              Show this help message", file=sys.stderr)
    print("  -t, --timeout SECONDS   Request timeout (default: 3600)", file=sys.stderr)
    print("  --notify                Sync send, no wait for reply (for notifications)", file=sys.stderr)
    print("  --no-wrap               Don't wrap with CCB protocol markers", file=sys.stderr)


def main(argv: list[str]) -> int:
    if len(argv) <= 1:
        _usage()
        return EXIT_ERROR

    # First argument must be the provider or instance
    target = argv[1].lower()

    if target in ("-h", "--help"):
        _usage()
        return EXIT_OK

    # Try to load Claude instances from providers.py and config
    try:
        from providers import list_claude_instances, is_claude_instance
        loaded_instances = list_claude_instances()
        _CLAUDE_INSTANCES.extend([i for i in loaded_instances if i != "default"])
    except Exception:
        pass

    # Also try to load instances directly from config file
    try:
        import json
        from pathlib import Path
        config_paths = [
            Path.cwd() / ".ccb_config" / "ccb.config",
            Path.home() / ".ccb" / "ccb.config"
        ]
        for config_path in config_paths:
            if config_path.exists():
                try:
                    content = config_path.read_text(encoding="utf-8-sig")
                    data = json.loads(content) if content.strip() else {}
                    if isinstance(data, dict) and "claude" in data:
                        claude_config = data["claude"]
                        if isinstance(claude_config, dict):
                            instances = claude_config.get("instances", [])
                            if isinstance(instances, list):
                                for inst in instances:
                                    if isinstance(inst, dict):
                                        inst_id = inst.get("id")
                                        if inst_id and inst_id not in _CLAUDE_INSTANCES:
                                            _CLAUDE_INSTANCES.append(inst_id)
                            break
                except Exception:
                    continue
    except Exception:
        pass

    # Resolve target to provider, instance_id
    provider, instance_id = _resolve_claude_target(target)

    if provider != "claude":
        print(f"[ERROR] Unknown target: {target}", file=sys.stderr)
        if _CLAUDE_INSTANCES != ["default"]:
            print(f"[ERROR] Available Claude instances: {', '.join(_CLAUDE_INSTANCES)}", file=sys.stderr)
        return EXIT_ERROR

    # Set instance_id in environment for daemon
    if instance_id and instance_id != "default":
        os.environ["CCB_CLAUDE_INSTANCE"] = instance_id

    # Parse remaining arguments
    timeout: float = 3600.0
    notify_mode = False
    no_wrap = False
    parts: list[str] = []

    it = iter(argv[2:])
    for token in it:
        if token in ("-h", "--help"):
            _usage()
            return EXIT_OK
        if token in ("-t", "--timeout"):
            try:
                timeout = float(next(it))
            except StopIteration:
                print("[ERROR] --timeout requires a number", file=sys.stderr)
                return EXIT_ERROR
            except ValueError:
                print("[ERROR] --timeout must be a number", file=sys.stderr)
                return EXIT_ERROR
            continue
        if token == "--notify":
            notify_mode = True
            continue
        if token == "--no-wrap":
            no_wrap = True
            continue
        parts.append(token)

    message = " ".join(parts).strip()
    if not message and not sys.stdin.isatty():
        message = read_stdin_text().strip()
    if not message:
        print("[ERROR] Message cannot be empty", file=sys.stderr)
        return EXIT_ERROR

    # Notify mode: sync send, no wait for reply (used for hook notifications)
    if notify_mode:
        cmd = ["lask", "--sync"]
        if no_wrap:
            cmd.append("--no-wrap")
        try:
            result = subprocess.run(
                cmd,
                input=message,
                capture_output=True,
                text=True,
                timeout=10
            )
            return result.returncode
        except subprocess.TimeoutExpired:
            return EXIT_OK
        except Exception as e:
            print(f"[ERROR] {e}", file=sys.stderr)
            return EXIT_ERROR

    # Default async mode: background task with hook callback
    task_id = make_task_id()
    log_dir = Path(tempfile.gettempdir()) / "ccb-tasks"
    log_dir.mkdir(parents=True, exist_ok=True)
    log_file = log_dir / f"ask-claude-{task_id}.log"

    # Detect caller from environment or default to "claude"
    caller = os.environ.get("CCB_CALLER", "claude")

    # Platform-specific background execution
    if os.name == "nt":
        # Windows: use PowerShell script to avoid .cmd escaping issues
        DETACHED_PROCESS = 0x00000008
        CREATE_NO_WINDOW = 0x08000000
        CREATE_NEW_PROCESS_GROUP = 0x00000200

        # Write message to temp file to avoid escaping issues
        msg_file = log_dir / f"ask-claude-{task_id}.msg"
        msg_file.write_text(message, encoding="utf-8")

        # Write PowerShell script
        script_file = log_dir / f"ask-claude-{task_id}.ps1"
        # Use here-string and file input to avoid all escaping issues
        instance_env = f'$env:CCB_CLAUDE_INSTANCE = "{instance_id}"' if instance_id else "# default instance"
        script_content = f'''$ErrorActionPreference = "SilentlyContinue"
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
[Console]::InputEncoding = [System.Text.Encoding]::UTF8
$OutputEncoding = [System.Text.Encoding]::UTF8
chcp 65001 > $null
$env:CCB_REQ_ID = "{task_id}"
$env:CCB_CALLER = "{caller}"
$env:CCB_WORK_DIR = "{os.getcwd()}"
{instance_env}
Get-Content -Path "{msg_file}" -Encoding UTF8 | & lask --timeout {timeout}
'''
        script_file.write_text(script_content, encoding="utf-8-sig")

        # Open log file for output
        log_handle = open(log_file, "w", encoding="utf-8")

        # Start PowerShell with minimal window flag only
        # Don't use DETACHED_PROCESS to allow proper file handle inheritance
        subprocess.Popen(
            ["powershell", "-ExecutionPolicy", "Bypass", "-NoProfile", "-File", str(script_file)],
            stdin=subprocess.DEVNULL,
            stdout=log_handle,
            stderr=subprocess.STDOUT,
            creationflags=CREATE_NO_WINDOW,
        )
    else:
        # Unix: use nohup to ensure process survives terminal close
        instance_export = f'export CCB_CLAUDE_INSTANCE="{instance_id}"' if instance_id else "# default instance"
        bg_script = f'''
export CCB_REQ_ID="{task_id}"
export CCB_CALLER="{caller}"
export CCB_WORK_DIR="{os.getcwd()}"
{instance_export}
lask --timeout {timeout} <<'ASKEOF'
{message}
ASKEOF
'''
        # Write script to temp file for nohup execution
        script_file = log_dir / f"ask-claude-{task_id}.sh"
        script_file.write_text(bg_script, encoding="utf-8")
        script_file.chmod(0o755)

        # Use nohup to run in background, independent of terminal
        subprocess.Popen(
            f'nohup sh "{script_file}" > "{log_file}" 2>&1 &',
            shell=True,
            stdin=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )

    provider_display = f"{instance_id or provider}".capitalize()
    print(f"{provider_display} processing (task: {task_id}, log: {log_file})...")
    return EXIT_OK


if __name__ == "__main__":
    sys.exit(main(sys.argv))
